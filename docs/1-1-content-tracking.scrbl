#lang scribble/manual

@(require scriblib/footnote)

@(define-footnote notes footnotes)

@title{代码仓库：目录里的内容追踪}

前面已经提过，Git做的是一件很原始的事情：为目录里的内容维护一系列快照。确认了这一基本任务，Git的很多内部设计就比较好理解了。

Git代码仓库的设计在多方面看起来都是比照着Unix文件系统的结构来的：@italic{文件系统}从一个根目录展开，根目录包含其它目录，多数目录里还包含叶节点，即@italic{文件}，文件存放着数据。关于文件内容的元数据（meta-data）存储在两类位置：文件名存储在该文件所在的目录文件中；文件的大小、文件类型、权限等信息则存储在指向这个文件的i-node@notes{译注：@hyperlink["https://zh.wikipedia.org/wiki/Inode"]{i-node}是Unix文件系统使用的一种数据结构}中。每个i-node都有一个唯一的编号用来标识它所关联的文件内容。你可能会有多个目录条目指向同一个i-node（即硬链接，hard links），但文件系统上真正“保管”文件内容的是这个i-node。

Git的内部设计与上述结构惊人地相似，尽管有一两个关键的区别。首先，文件的内容存放在一些@italic{二进制对象（blob）}@notes{译注：blob--- Binary Large OBject (BLOB) }中，作为@italic{树结构（tree）}的叶节点，对应于文件系统中的文件。而Git的@italic{树}的跟文件系统的目录结构如出一辙。然后，正如i-node以系统分配的编号来唯一标识，这里的blob是以SHA1算法对其大小和内容计算得到的哈希id来命名。这样做的意图没有别的，就是要生成一个值，就像i-node，但还多了另外两个属性：第一，这个值可以验证blob的内容永远不变；第二，同样的内容永远会由一摸一样的blob来保存，不管它出现在哪儿（比如在不同的commits里，不同的repository里，甚至在互联网上的任何地方）。如果有多棵树引用了同样名字的blob，就相当于是硬连接（hard-linking）：blob不会从你的代码仓库消失，只要还有至少一个链接指向它。

Git的blob和文件系统的文件有一个区别是，blob不存储关于自己内容的元数据（metadata）。所有这类信息都在blob所在的树上。可能有一棵树知道这个blob是一个名为“foo”的文件，它创建于2004年8月，而另一棵树可能认为同样的blob是一个名为“bar”的文件，而且创建时间在5年之后。然而在正常的文件系统里，类似这样的两个内容完全相同但元信息不同的文件一定是以两个独立的文件存在的。为什么会有这样的区别？主要原因是，文件系统设计成这样是为了支持文件的变化，但Git不用。Git仓库里保存的数据都是不可变的@notes{译注：Git保存的都是文件快照}，这一特点导致Git需要不同的设计。而这样设计结果还带来了别的好处，即存储空间大大节省，因为所有拥有同样内容的对象都可以共享同一份存储，不管它出现在仓库的什么位置。


@(footnotes)
